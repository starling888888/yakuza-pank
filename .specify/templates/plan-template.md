# 実装計画: [機能]

**ブランチ**: `[###-feature-name]` | **日付**: [DATE] | **仕様**: [link]
**入力**: `/specs/[###-feature-name]/spec.md`からの機能仕様

## 実行フロー (/plan コマンドの範囲)
```
1. 入力パスから機能仕様をロード
   → 見つからない場合: エラー「{path}に機能仕様がありません」
2. 技術的コンテキストを埋める (NEEDS CLARIFICATIONをスキャン)
   → コンテキストからプロジェクトタイプを検出 (web=フロントエンド+バックエンド、mobile=アプリ+API)
   → プロジェクトタイプに基づいて構造決定を設定
3. 憲法文書の内容に基づいて憲法チェックセクションを埋める。
4. 以下の憲法チェックセクションを評価
   → 違反がある場合: 複雑性追跡に文書化
   → 正当化できない場合: エラー「まずアプローチを簡素化してください」
   → 進捗追跡を更新: 初期憲法チェック
5. フェーズ0を実行 → research.md
   → NEEDS CLARIFICATIONが残っている場合: エラー「不明な点を解決してください」
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有のテンプレートファイル (例: Claude Codeの場合は`CLAUDE.md`、GitHub Copilotの場合は`.github/copilot-instructions.md`、Gemini CLIの場合は`GEMINI.md`、Qwen Codeの場合は`QWEN.md`、またはopencodeの場合は`AGENTS.md`)。
7. 憲法チェックセクションを再評価
   → 新しい違反がある場合: 設計をリファクタリングし、フェーズ1に戻る
   → 進捗追跡を更新: 設計後の憲法チェック
8. フェーズ2を計画 → タスク生成アプローチを記述 (tasks.mdを作成しない)
9. 停止 - /tasks コマンドの準備完了
```

**重要**: /plan コマンドはステップ7で停止します。フェーズ2-4は他のコマンドによって実行されます。
- フェーズ2: /tasks コマンドがtasks.mdを作成
- フェーズ3-4: 実装実行 (手動またはツール経由)

## 概要
[機能仕様から抽出: 主要要件 + 調査からの技術的アプローチ]

## 技術的コンテキスト
**言語/バージョン**: [例: Python 3.11, Swift 5.9, Rust 1.75 または NEEDS CLARIFICATION]  
**主要依存関係**: [例: FastAPI, UIKit, LLVM または NEEDS CLARIFICATION]  
**ストレージ**: [該当する場合、例: PostgreSQL, CoreData, ファイル または N/A]  
**テスト**: [例: pytest, XCTest, cargo test または NEEDS CLARIFICATION]  
**ターゲットプラットフォーム**: [例: Linuxサーバー, iOS 15+, WASM または NEEDS CLARIFICATION]
**プロジェクトタイプ**: [単一/ウェブ/モバイル - ソース構造を決定]  
**パフォーマンス目標**: [ドメイン固有、例: 1000 req/s, 10k lines/sec, 60 fps または NEEDS CLARIFICATION]  
**制約**: [ドメイン固有、例: <200ms p95, <100MBメモリ, オフライン対応 または NEEDS CLARIFICATION]  
**規模/範囲**: [ドメイン固有、例: 1万ユーザー, 100万LOC, 50画面 または NEEDS CLARIFICATION]

## 憲法チェック
*ゲート: フェーズ0の調査前に合格する必要があります。フェーズ1の設計後に再チェックしてください。*

*   **原則I (MVP)**: この機能は、価値を提供する最小限の範囲に限定されているか？
*   **原則II (静的サイト優先)**: この設計は、サーバーサイドの動的処理を不必要に導入していないか？
*   **原則III (テスト)**: E2Eテストと、必要に応じて視覚的リグレッションテストが計画されているか？
*   **原則IV (コンポーネント)**: UIは再利用可能なコンポーネントとして設計されているか？
*   **原則V (自動デプロイ)**: デプロイメントパイプラインへの影響は考慮されているか？

## プロジェクト構造

### ドキュメント (この機能)
```
specs/[###-feature]/
├── plan.md              # このファイル (/plan コマンド出力)
├── research.md          # フェーズ0出力 (/plan コマンド)
├── data-model.md        # フェーズ1出力 (/plan コマンド)
├── quickstart.md        # フェーズ1出力 (/plan コマンド)
├── contracts/           # フェーズ1出力 (/plan コマンド)
└── tasks.md             # フェーズ2出力 (/tasks コマンド - /planでは作成されません)
```

### ソースコード (リポジトリルート)
```
# オプション1: 単一プロジェクト (デフォルト)
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# オプション2: ウェブアプリケーション (「フロントエンド」+「バックエンド」が検出された場合)
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API (「iOS/Android」が検出された場合)
api/
└── [上記バックエンドと同じ]

ios/ または android/
└── [プラットフォーム固有の構造]
```

**構造決定**: [技術的コンテキストがウェブ/モバイルアプリを示さない限り、オプション1がデフォルト]

## フェーズ0: 概要と調査
1. 上記の**技術的コンテキストから不明な点を抽出**:
   - 各NEEDS CLARIFICATION → 調査タスク
   - 各依存関係 → ベストプラクティスタスク
   - 各統合 → パターンタスク

2. **調査エージェントを生成してディスパッチ**:
   ```
   技術的コンテキストの各不明点について:
     タスク: 「{機能コンテキスト}の{不明点}を調査」
   各技術選択について:
     タスク: 「{ドメイン}における{技術}のベストプラクティスを見つける」
   ```

3. `research.md`に**調査結果を統合** (形式):
   - 決定: [選択されたもの]
   - 根拠: [選択理由]
   - 検討された代替案: [他に評価されたもの]

**出力**: すべてのNEEDS CLARIFICATIONが解決されたresearch.md

## フェーズ1: 設計と契約
*前提条件: research.mdが完了していること*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - エンティティ名、フィールド、関係
   - 要件からの検証ルール
   - 該当する場合、状態遷移

2. 機能要件から**API契約を生成**:
   - 各ユーザーアクション → エンドポイント
   - 標準のREST/GraphQLパターンを使用
   - OpenAPI/GraphQLスキーマを`/contracts/`に出力

3. 契約から**契約テストを生成**:
   - エンドポイントごとに1つのテストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗するはず (まだ実装なし)

4. ユーザー物語から**テストシナリオを抽出**:
   - 各物語 → 統合テストシナリオ
   - クイックスタートテスト = 物語の検証ステップ

5. **エージェントファイルを段階的に更新** (O(1)操作):
   - `.specify/scripts/bash/update-agent-context.sh gemini`を実行
     **重要**: 上記の通り正確に実行してください。引数を追加したり削除したりしないでください。
   - 存在する場合: 現在の計画からの新しい技術のみを追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新 (最後の3つを保持)
   - トークン効率のために150行未満に保つ
   - リポジトリルートに出力

**出力**: data-model.md, /contracts/*, 失敗するテスト, quickstart.md, エージェント固有のファイル

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが何をするかを記述します - /plan中に実行しないでください*

**タスク生成戦略**:
- `.specify/templates/tasks-template.md`をベースとしてロード
- フェーズ1の設計ドキュメント (契約、データモデル、クイックスタート) からタスクを生成
- 各契約 → 契約テストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザー物語 → 統合テストタスク
- テストをパスさせるための実装タスク

**順序付け戦略**:
- TDD順序: 実装前にテスト
- 依存関係順序: UIの前にサービス、サービスの前にモデル
- 並列実行 (独立したファイル) のために [P] をマーク

**推定出力**: tasks.mdに25-30個の番号付き、順序付けされたタスク

**重要**: このフェーズは/tasksコマンドによって実行され、/planでは実行されません

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドの範囲外です*

**フェーズ3**: タスク実行 (/tasksコマンドがtasks.mdを作成)
**フェーズ4**: 実装 (憲法原則に従ってtasks.mdを実行)
**フェーズ5**: 検証 (テストを実行、quickstart.mdを実行、パフォーマンス検証)

## 複雑性追跡
*憲法チェックに正当化が必要な違反がある場合にのみ記入*

| 違反 | 必要性 | より単純な代替案が却下された理由 |
|-----------|------------|-------------------------------------|
| [例: 4番目のプロジェクト] | [現在のニーズ] | [なぜ3つのプロジェクトでは不十分か] |
| [例: リポジトリパターン] | [特定の問題] | [なぜ直接DBアクセスでは不十分か] |


## 進捗追跡
*このチェックリストは実行フロー中に更新されます*

**フェーズステータス**:
- [ ] フェーズ0: 調査完了 (/plan コマンド)
- [ ] フェーズ1: 設計完了 (/plan コマンド)
- [ ] フェーズ2: タスク計画完了 (/plan コマンド - アプローチのみ記述)
- [ ] フェーズ3: タスク生成 (/tasks コマンド)
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

---
*憲法v0.1.0に基づく - `/memory/constitution.md`を参照*